# chap 14 平行・並列処理の手法と設計パターン

## 1 平行・並列処理の手法のパターン
実現手法には大きく分けてマルチプロセス、イベント駆動、マルチスレッド、ストリーミング・プロセッシングの四つのパターンがある。
これらの中から選択することはプログラムの構造を大きく変えるようなデザインの決定になる。
そのため、必要な処理がCPUバウンドなのか、I/Oバウンドなのかを判断し適切な手法を選択する。

### 1.1 マルチプロセス
複数コアのコンピュータであればそれぞれのプロセスは並行に動く。シングルコアの場合も時間割でCPUの占有時間を分け合って平行に動く。

メリット・デメリット
- プロセス同士はメモリが分割されるため、安全性が高い
- 起動に時間がかかる
- プロセス間でデータ共有を行うために共有メモリやプロセス間通信、メッセージキューなどが必要になる
- プロセス切り替え時にコンテキストスイッチが発生するが、これは実行コストがかかる

### 1.2 イベント駆動
- 並列化ではなく、並行処理のために使用される。
- ファイルI/OやネットワークアクセスなどI/O街が多いプログラムで使用される
- 一つのスレッドが処理を担当するため、データ競合が発生しにくい
- イベント駆動単体ではCPUを使いこなしにくい。
    - CPUのコア数分プロセスを起動し、その中でイベント駆動する
    - 処理部分をスレッドやプロセスで並行実行する\
    などの必要があり
      
### 1.3 マルチスレッド
- CPUのパフォーマンスを引き出しやすい
- スレッド間のデータ共有が楽

デメリット（OSスレッド)
- 比較的大きなスタックメモリ（１～２メガバイト）
- 起動やや時間かかる
    - プロセス同様、先にスレッドを作成してスレッドプールに置いとくことがある
- コンテキストスイッチのコストもプロセスと同じだけかかる

^このデメリットはgoroutineなどの軽量スレッドであれば軽減される

### 1.4 ストリーミング・プロセッシング
GPUのスレッディングモデルでおこなう
- スレッドはすでに最大限作成されており、作成も削除もない
- スレッドの切り替えはハードウェアで高速に行われる
- GPUでは同時実行するスレッドの間でメモリアドレス（IP）を共有している
    - 分岐ダイバージェンス：コードブロックごとに分けて実行
    

## 2 Goにおける並行・並列処理のパターン集

### 2.1 同期 -> 非同期化
- 重い処理をタスクに分けること
    - Goでは重い処理をgoroutineの中で実行して非同期化する

### 2.2 非同期 -> 同期化
- 非同期化したらどこかで同期しなくてはならない
    - Goはmain関数が終われば処理が終わるので、goroutineのタスクが残っていても処理が終わる
    - 案１：チャネル
        - selectを使用しない場合、一つのgoroutineが同時に読み込めるチャネルは一つのみ
        - select（default節なしでイベント駆動、ありで非同期I/O）を使用する場合
    - 案２：syncパッケージ
    
### 2.3 タスク生成と処理を分ける：Producer-Consumer
- タスク生成：Producer
- タスク処理：Consumer
- チャネルでProducerとConsumerを接続することで実現可能
    - Consumerの数によりスケールできる
- プロセス間でProducer-Consumerパターンを実現するには、メッセージキューというミドルウェアで仲介する

### 2.4 開始した順で処理する：チャネルのチャネル
- channelはFIFOのキューとして使える。


### 2.5 タスク処理阿賀詰まったら待機：バックプレッシャー
- バックプレッシャー：ネットワーク用語で元々は送信側にパケットがあふれそうになったら通知するもの
- Goではgoroutineの入力にバッファ付きのチャネルを使うだけでバックプレッシャーを実現できる

### 2.6 並列forループ
- forループないをすべてgoroutineで実行すれば、並列化できる
- I/Oバウンドの場合は効果的
- ループ変数内の実体は一つしかないため、loopごとにgoroutineに引数として渡してコピーが作られるようにする必要がある。[参照:for_loop.go](./for_loop.go)

### 2.7 決まった数のgoroutineでタスクを消化：ワーカープール
- スレッドプール≒プロセスプール≒ワーカープール
- CPUコア数分のワーカーをgoroutineを作って処理するのが効果的な場合がある。[参照:worker_pool.go](./worker_pool.go)

### 2.8 依存関係のあるタスクを表現する：Future/Promise
- Future:将来得られるはずの入力 -> Promise:値を提供すること -> 処理の実行
- Goでは以下で実現可能
  - すべてのタスク：goroutine
  - Future：バッファなしチャネルの受信
  - Promise：同じチャネルへの送信
  

### 2.9 イベントの流れを定義する：ReactiveX

### 2.10 自律した複数のシステムで協調動作：アクターモデル


