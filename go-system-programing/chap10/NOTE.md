# chap 10

### 10.1 ファイルの変更監視（syscall.Inotify）

- 監視するファイルをあらかじめ決めておいて、変更があったらOSに教えてもらう（パッシブな方式）
- 定期的にファイルの差異を探しに行く（アクティブな方式）
- アクティブな方式は監視対象の増加につれ、CPU負荷やIO負荷が増加してしまう。
- パッシブな方式のソリューションの一つであるfsnotifyはOSごとの差異を吸収してくれる（マルチプラットフォーム）

### 10.2 ファイルのロック（syscall.Flock）

- POSIX系OSではsyscall.Flock()がファイルのロックを行う
    - syscall.Flock()はあくまで印
    - ロックの確認を行わないプロセスは自由にかきこみできてしまう（アドバイザリーロック）
    - fcntlシステムコールでは強制力のあるロックもできる
- WindowsではFockFileEx()によりファイルのロックを行う（強制ロック）
- ノンブロッキングモードは並行処理が簡単に書けるGo言語では必要ない

- 実装がうまくいかなかった（バージョンが新しくなってAPIが変更された？）

### 10.3 ファイルのメモリへのマッピング（syscall.Mmap）
- mmapはシンプルなsyscall.mmapラッピングパッケージ
  - コピーオンライト機能でメモリを節約できる
  - メモリ領域への実行許可などができる
  
### 10.4 同期・非同期／ブロッキング・ノンブロッキング
- 同期・ブロッキング
  - コードは簡潔だがパフォーマンスは悪い
- 同期・ノンブロッキング
  - 処理が完了するまで聞き続ける
- 非同期・ブロッキング
  - IO多重化とも呼ばれる
  - 実行準備が完了したものがあれば通知される
- 非同期・ノンブロッキング
  - メインプロセスとは別のスレッドで処理を行い、完了したら通知を受け取る