# chap 15 Go言語のメモリ管理

### 1.5 ユーザーコードでメモリを使う
C/C++
- ローカル変数として宣言するとスタックメモリを使用する
- malloc()やnewを使って宣言するとヒープメモリを使用する
- deleteやfree()でリソースの開放を行う

Go言語
- スタックとヒープどちらを使用するかはコンパイラが自動で判断する
- デフォルトではスタックを使用する（速いから）
- 外部の関数に渡すなどの処理があるとヒープへと移動させされる
- ガベージコレクタがリソースを自動で開放する

## 2 Go言語の配列
- Goの配列は固定長（可変長はsliceと呼ぶ)
- 初期値を与えないと0値が入る

## 3 sliceなど
- Goの配列をバックエンドとして、使いやすくしたフロントエンドがスライス
- スライスの実体は、スライスの先頭へのポインタ、スライスの長さ、スライスが確保している要素数を持つ者


### 3.1 sliceの作成方法
- 既存の配列を参照する
- 何も参照しない、からのスライス
    - 初めて値が入ったときにメモリを確保する
- 配列と同時にスライスを作成する
    - 要素数が決まっているならば、makeなどで作成するべき
    - メモリの再確保は大きなオーバーヘッドとなる
    
### 3.2 スライスのメモリ確保の方法
- append()関数が良しなにメモリを確保してくれる
    - 呼び出しに時間がかかる可能性
        - 何度も中間配列が作成されるコスト（2->4->8->16,,,,etc）：最初からメモリを確保すべき
        - ガベージコレクタが中間配列を削除するためのコスト
        - 中間配列の間で値がコピーされるコスト
        - 2倍ずつ伸びるので必要以上のメモリが確保される可能性
- 必要に応じてappend()関数に頼らない設計
    - make関数であらかじめ必要数を確保する
    - copy関数で任意の量の値のコピーを一括で行う（システムコール回数の削減）
    

### 3.3 マップとパフォーマンス改善のヒント
- 8個の要素をまとめたパケットという単位で値を管理する
- 配列と同様に要素数が増えるごとにハッシュ値の管理テーブル、メモリの確保が必要になる
- makeで宣言できる状況ならそうした方がパフォーマンス向上につながる

### 3.4 sync.Poolによる、アロケート回数の削減
- オブジェクトのキャッシュを実現する構造体
- あらかじめ保持、初期化する構造体の型がわかっているため最低限の処理で済む
- 構造体が新たに必要となった際のメモリ確保が必要ない
- sync.Pool、runtime.GC()四でも消えなかった（改善された？）

## 4 ガベージコレクタ
- マーク・アンド・スイープ
    - 必要なデータか否かを判断してマークし、次のフェーズで削除する
        - 時間ごとにスキャンを行い、スキャン回数を削減するもの
        - 参照回数で管理など
        - などなど
    
## 5 アプリケーションのメモリ配置
- 

### 5.1 アドレス空間配置のランダム化
- 実行ファイルは位置独立の実行形式（PIE）
- OSは実行形式がPIEの場合はプログラムロード時のアドレスをランダムにし、セキュリティホールを突かれたとしても重篤な問題にならないようにする

### 5.2 実行ファイルにアセットをバンドル
- 